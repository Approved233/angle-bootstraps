From 7c7a7cf6815ebe52596166ac8a341177e8d30c83 Mon Sep 17 00:00:00 2001
From: Shahbaz Youssefi <syoussefi@chromium.org>
Date: Thu, 09 Jan 2020 11:14:47 -0500
Subject: [PATCH] Vulkan: Workaround vertex attributes vs stride issue on AMD

Under robustBufferAccess, Vulkan states that:

Vertex input attributes are considered out of bounds if the offset of
the attribute in the bound vertex buffer range plus the size of the
attribute is greater than either:

- vertexBufferRangeSize, if bindingStride == 0; or
- (vertexBufferRangeSize - (vertexBufferRangeSize % bindingStride))

The latter implies that if the buffer size is not a multiple of the
vertex attribute stride, what lies beyond the last multiple of stride is
considered out of bounds.

It also says:

Out-of-bounds buffer loads will return any of the following values:

- Values from anywhere within the memory range(s) bound to the buffer
  (possibly including bytes of memory past the end of the buffer, up to
  the end of the bound range).
- Zero values, or (0,0,0,x) vectors for vector reads where x is a valid
  value represented in the type of the vector components and may be any
  of ...

The first bullet point indicates that the driver is allowed to load the
attribute values from the buffer if its range still lies within the
buffer size.

Take the following example:

- Buffer size = 12
- Attribute stride = 8
- Attribute offset = 0
- Attribute size = 4

Basically the buffer is thus laid out as follows:

          attr stride
      _________/\_________
     /                    \
    +----------+----------+----------+
    | vertex 0 | padding  | vertex 1 |
    +----------+----------+----------+
     \___ ____/
         V
     attr size

In the above example, the attribute for vertex 1 is considered out of
bounds, but the driver is allowed to either read it correctly, or return
(0, 0, 0, 1) for it.

Most drivers implement the former, while AMD implements the latter.
This change introduces a workaround for AMD where
GL_MAX_VERTEX_ATTRIB_STRIDE is limited to 2048 (the common value for it
according to gpuinfo.org) and conservatively rounds up every buffer
allocation to that size.

While technically, this workaround should be applied on any device with
the robustBufferAccess feature enabled, it is currently limited to AMD
to avoid the inefficiency.  A possible future revision of Vulkan may
relax the above restrictions.

Bug: angleproject:2848
Change-Id: Ida5ae5d777da10f22ce8be5a09a7644b5bbd778e
---

diff --git a/include/platform/FeaturesVk.h b/include/platform/FeaturesVk.h
index 17da707..43f170b 100644
--- a/include/platform/FeaturesVk.h
+++ b/include/platform/FeaturesVk.h
@@ -213,6 +213,25 @@
         "RewriteStructSamplers behavior, which produces fewer.",
         &members, "http://anglebug.com/2703"};
 
+    // If the robustBufferAccess feature is enabled, Vulkan considers vertex attribute accesses only
+    // valid up to the last multiple of stride.  If a vertex's attribute range is such that it falls
+    // within the range of the buffer, but beyond the last multiple of stride, the driver is allowed
+    // to either read that range from the buffer anyway, or to return (0, 0, 0, 1).  Most drivers
+    // implement the former, while amdvlk on Linux and AMD's windows driver implement the latter.
+    // For the latter, this workaround limits GL_MAX_VERTEX_ATTRIB_STRIDE to a reasonable value, and
+    // rounds up every buffer allocation size to be a multiple of that.
+    // http://anglebug.com/2514
+    Feature roundUpBuffersToMaxVertexAttribStride = {
+        "round_up_buffers_to_max_vertex_attrib_stride", FeatureCategory::VulkanWorkarounds,
+        "If the robustBufferAccess feature is enabled, Vulkan considers vertex attribute accesses "
+        "only valid up to the last multiple of stride. If a vertex's attribute range is such that "
+        "it falls within the range of the buffer, but beyond the last multiple of stride, the "
+        "driver is allowed to either read that range from the buffer anyway, or to return "
+        "(0, 0, 0, 1). Most drivers implement the former, while some drivers the latter. For the "
+        "latter, this workaround limits GL_MAX_VERTEX_ATTRIB_STRIDE to a reasonable value, and "
+        "rounds up every buffer allocation size to be a multiple of that.",
+        &members, "http://anglebug.com/2848"};
+
     // Whether the VkDevice supports the VK_EXT_swapchain_colorspace extension
     // http://anglebug.com/2514
     Feature supportsSwapchainColorspace = {
diff --git a/src/libANGLE/renderer/vulkan/BufferVk.cpp b/src/libANGLE/renderer/vulkan/BufferVk.cpp
index 4da5544..8ed1930 100644
--- a/src/libANGLE/renderer/vulkan/BufferVk.cpp
+++ b/src/libANGLE/renderer/vulkan/BufferVk.cpp
@@ -93,7 +93,8 @@
                                 size_t size,
                                 gl::BufferUsage usage)
 {
-    ContextVk *contextVk = vk::GetImpl(context);
+    ContextVk *contextVk   = vk::GetImpl(context);
+    RendererVk *rendererVk = contextVk->getRenderer();
 
     if (size > static_cast<size_t>(mState.getSize()))
     {
@@ -122,6 +123,13 @@
         createInfo.queueFamilyIndexCount = 0;
         createInfo.pQueueFamilyIndices   = nullptr;
 
+        if (rendererVk->getFeatures().roundUpBuffersToMaxVertexAttribStride.enabled)
+        {
+            const GLint maxVertexAttribStride = rendererVk->getNativeCaps().maxVertexAttribStride;
+            createInfo.size =
+                roundUp(createInfo.size, static_cast<VkDeviceSize>(maxVertexAttribStride));
+        }
+
         // Assume host visible/coherent memory available.
         const VkMemoryPropertyFlags memoryPropertyFlags =
             (VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT);
diff --git a/src/libANGLE/renderer/vulkan/RendererVk.cpp b/src/libANGLE/renderer/vulkan/RendererVk.cpp
index 4847ef9..b36ad49 100644
--- a/src/libANGLE/renderer/vulkan/RendererVk.cpp
+++ b/src/libANGLE/renderer/vulkan/RendererVk.cpp
@@ -1436,6 +1436,9 @@
     // Disabled on AMD/windows due to buggy behavior.
     ANGLE_FEATURE_CONDITION((&mFeatures), disallowSeamfulCubeMapEmulation, IsWindows() && isAMD);
 
+    ANGLE_FEATURE_CONDITION((&mFeatures), roundUpBuffersToMaxVertexAttribStride,
+                            isAMD && mPhysicalDeviceFeatures.robustBufferAccess);
+
     ANGLE_FEATURE_CONDITION((&mFeatures), forceD16TexFilter, IsAndroid() && isQualcomm);
 
     ANGLE_FEATURE_CONDITION((&mFeatures), disableFlippingBlitWithCommand,
diff --git a/src/libANGLE/renderer/vulkan/vk_caps_utils.cpp b/src/libANGLE/renderer/vulkan/vk_caps_utils.cpp
index 34448ed..0329eb4 100644
--- a/src/libANGLE/renderer/vulkan/vk_caps_utils.cpp
+++ b/src/libANGLE/renderer/vulkan/vk_caps_utils.cpp
@@ -186,6 +186,17 @@
         std::min(static_cast<uint32_t>(std::numeric_limits<uint16_t>::max()),
                  limitsVk.maxVertexInputBindingStride);
 
+    if (getFeatures().roundUpBuffersToMaxVertexAttribStride.enabled)
+    {
+        // With this workaround, we need to round up buffer sizes to maxVertexAttribStride.  To
+        // avoid memory waste, we should keep this value small.  According to gpuinfo.org,
+        // GL_MAX_VERTEX_ATTRIB_STRIDE takes the value 2048 in most drivers.  We thus choose the
+        // same value as maximum stride.
+        constexpr GLint kMaxVertexAttribStride = 2048;
+        mNativeCaps.maxVertexAttribStride =
+            std::min(kMaxVertexAttribStride, mNativeCaps.maxVertexAttribStride);
+    }
+
     mNativeCaps.maxElementsIndices  = std::numeric_limits<GLint>::max();
     mNativeCaps.maxElementsVertices = std::numeric_limits<GLint>::max();
 
